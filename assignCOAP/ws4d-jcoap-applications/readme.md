# 1. Compilation steps for client 
## 1.1 On Raspberry Pi(same as in the provided COAP client implementation)
$ export JAVA_HOME=/usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/
$ export PATH=$PATH:$JAVA_HOME/bin
$ cd /home/pi/workspaceJava/COAP/ws4d-jcoap-applications/src
$ export CLASSPATH_COAP=.:../lib/ws4d-jcoap.jar:../lib/commons-cli-1.2.jar:../lib/log4j-1.2.16.jar:../lib/commons-codec-1.4.jar:../lib/commons-logging-1.1.1.jar:../lib/ehcache-core-2.4.3.jar:../lib/httpasyncclient-4.0-alpha2.jar:../lib/httpclient-4.2.jar:../lib/httpcore-4.2.jar:../lib/httpcore-nio-4.2.jar:../lib/slf4j-api-1.6.1.jar:../lib/slf4j-jdk14-1.6.1.jar
$ javac -classpath $CLASSPATH_COAP -d ../bin org/ws4d/coap/client/BasicCoapClient.java
$ cd ../bin
$ java -classpath $CLASSPATH_COAP org/ws4d/coap/client/BasicCoapClient 192.168.1.209 5683
## 1.2. On Windows host
Open up the project in your editor of choice (Eclipse/IntelliJ etc...). Fix the classpath of the project(namely from where it loads the libraries), for Eclipse this is done by right-clicking on the project->Build Path->Configure build path, and then in the Libraries tab, click on each one, then Edit and then navigate to the respective location where the .jar is located.
Then, in the BasicCoapClient.java file, modify the "SERVER_ADDRESS" variable with the address of your server.
Finally, run the client as a Java application.

# 2. Compilation steps for server
## 2.1. On Raspberry Pi(same as in the provided COAP server implementation)
$ export JAVA_HOME=/usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/
$ export PATH=$PATH:$JAVA_HOME/bin
$ cd /home/pi/workspaceJava/COAP/ws4d-jcoap-applications/src
$ export CLASSPATH_COAP=.:../lib/ws4d-jcoap.jar:../lib/commons-cli-1.2.jar:../lib/log4j-1.2.16.jar:../lib/commons-codec-1.4.jar:../lib/commons-logging-1.1.1.jar:../lib/ehcache-core-2.4.3.jar:../lib/httpasyncclient-4.0-alpha2.jar:../lib/httpclient-4.2.jar:../lib/httpcore-4.2.jar:../lib/httpcore-nio-4.2.jar:../lib/slf4j-api-1.6.1.jar:../lib/slf4j-jdk14-1.6.1.jar
$ javac -classpath $CLASSPATH_COAP -d ../bin org/ws4d/coap/server/BasicCoapServer.java
$ cd ../bin
$ java -classpath $CLASSPATH_COAP org/ws4d/coap/client/BasicCoapServer

## 2.2. On Windows host
Open up the project in your editor of choice (Eclipse/IntelliJ etc...). Fix the classpath of the project(namely from where it loads the libraries), for Eclipse this is done by right-clicking on the project->Build Path->Configure build path, and then in the Libraries tab, click on each one, then Edit and then navigate to the respective location where the .jar is located. 
Then, run the server as a Java application.

# 3. Code
## 3.1. Chosen implementation
For this project, I've used the already provided implementation of both CoAP client ("https://github.com/critoma/armasmiot/blob/master/labs/workspaceiotgwjava/CoapServer/java_samples/ws4d-jcoap-applications/src/org/ws4d/coap/client/BasicCoapClient.java") and server ("https://github.com/critoma/armasmiot/blob/master/labs/workspaceiotgwjava/CoapServer/java_samples/ws4d-jcoap-applications/src/org/ws4d/coap/server/BasicCoapServer.java") and removed all other files from the project ("https://github.com/critoma/armasmiot/blob/master/labs/workspaceiotgwjava/CoapServer/java_samples/ws4d-jcoap-applications/src/org/ws4d/coap/client/BasicCoapClient.java") keeping just the required libraries and the aforementioned files.
I've then proceeded to modify these files to include the required specifications for this assignment, namely authentication via digital signatures and confidentiality, via symmetric encryption.
For this, I've generated a certificate, named "CoAPClientX509.cer" (it was generated using keytool), which will be used server-side for signature verification. From said certificate, I've extracted the private key and saved it as "key.pem", in order to use it client-side for signature generation (private key was obtained by converting the jks key store generated by keytool, saving it as PKCS12 and then using openssl to extract the key). I have also removed the "Bag attributes" leftovers from key generation from "key.pem" for easier parsing of the key client-side.
## 3.2. Generating the session AES key
 - SUPPOSITION: The server already has the client's certificate, most likely sent on creating the connection. In my case, the server already has the certificate, instead of programming another endpoint and calling that one first for sending the ceritifcate over. This was done for the ease of the implementation.
The generation of the session key is done server-side. 
On the client, after first connecting, I've programmed a request to the URI "/generate", which will trigger this generation of the key (I've also set the token to "gen" for this request client-side). When the server receives a request for that endpoint, it proceeds to generate the key (AES 128-bit key using "SecureRandom"), encrypt it with the client's public key and send it as a response. When the client receives a response with the token "gen", it uses its private key to decrypt the key and save it internally.
## 3.3. Other suppositions
 - SUPPOSITION: The server only has one client. This is because the server has an internal attribute of the type "byte[]" named "AESkey", which holds the session key. If it were for multiple clients, that attribute would have became a dictionary, having as key "objectId/instanceId", and as value the session key for that objectId & instanceId combination. This was done for the ease of the implementation.

## 3.4. Client code
```JAVA
package org.ws4d.coap.client;

import java.io.File;
import java.net.InetAddress;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import org.ws4d.coap.Constants;
import org.ws4d.coap.connection.BasicCoapChannelManager;
import org.ws4d.coap.interfaces.CoapChannelManager;
import org.ws4d.coap.interfaces.CoapClient;
import org.ws4d.coap.interfaces.CoapClientChannel;
import org.ws4d.coap.interfaces.CoapRequest;
import org.ws4d.coap.interfaces.CoapResponse;
import org.ws4d.coap.messages.CoapRequestCode;

public class BasicCoapClient implements CoapClient {
    private static String SERVER_ADDRESS = "localhost";
    private static int PORT = Constants.COAP_DEFAULT_PORT;
    static int counter = 0;
    CoapChannelManager channelManager = null;
    CoapClientChannel clientChannel = null;
    byte[] AESkey = null;
    PrivateKey privKey = null;

    public static void main(String[] args) {
	if (args != null && args.length >= 1) {
		SERVER_ADDRESS = args[0];
		if (args.length >= 2)
			PORT = Integer.parseInt(args[1]);
	}
        System.out.println("Start CoAP Client: " + SERVER_ADDRESS);
        BasicCoapClient client = new BasicCoapClient();
        client.channelManager = BasicCoapChannelManager.getInstance();
        client.runTestClient();
    }
    
    public void runTestClient(){
    	try {
			clientChannel = channelManager.connect(this, InetAddress.getByName(SERVER_ADDRESS), PORT);
			// send generate request
			CoapRequest coapRequest = clientChannel.createRequest(true, CoapRequestCode.POST);
			coapRequest.setToken("gen".getBytes());
			coapRequest.setUriPath("/generate");
			clientChannel.sendMessage(coapRequest);
			System.out.println("Sent generate request\nSleeping for 10s awaiting for the key");
			Thread.sleep(10000); // awaiting for session key to be received
			// suppose we have a temperature sensor which sends its values => objectId = 3303, resourceId = 5700
			while(true) {
				// generate a float for the temp value and build the JSON according to IPSO
				SecureRandom r = new SecureRandom();
				float random = -40f + r.nextFloat() * 80f;
				CoapRequest coapRequestTemp = clientChannel.createRequest(true,  CoapRequestCode.POST);
				coapRequestTemp.setUriPath("3303/0/5700");
				coapRequestTemp.setToken("temp".getBytes());//set token to not have it somehow match the first letter of generation token "gen"
				String jsonIPSO = "{\n\t\"timestamp\": " + System.currentTimeMillis() + ",\n\t\"values\": [{\n\t\t\"objectId\": 3303,\n\t\t\"instanceId\": 0,\n\t\t\"resourceId\": 5700,\n\t\t\"datatype\": Float,\n\t\t\"value\": " + random + "\n\t]}\n}";
				System.out.println("Data to be sent:\n" + jsonIPSO);
				// init AES cipher for encryption of payload and encrypt it
				Cipher AEScipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
				SecretKeySpec keySpec = new SecretKeySpec(this.AESkey, "AES");
				AEScipher.init(Cipher.ENCRYPT_MODE, keySpec);
				byte[] encPayload = AEScipher.doFinal(jsonIPSO.getBytes());
				// prepare to sign and sign the encrypted payload
				Signature signature = Signature.getInstance("SHA512withRSA");
				signature.initSign(this.privKey);
				signature.update(encPayload);
				byte[] sign = signature.sign();
				// add signature length at first position in payload; then add signature; then the actual encrypted payload
				int sizeOfPayload = 4 + sign.length + encPayload.length;
				byte[] payload = new byte[sizeOfPayload];
				ByteBuffer aux = ByteBuffer.allocate(4);
				aux.putInt(sign.length);
				for(int i = 0; i < 4; i++) {
					payload[i] = aux.array()[i];
				}
				for(int i = 4; i < sign.length + 4; i++) {
					payload[i] = sign[i - 4];
				}
				// payload[5] = (byte) 0xf5; - uncomment to test sign mismatch
				for(int i = sign.length + 4; i < sizeOfPayload; i++) {
					payload[i] = encPayload[i - sign.length - 4];
				}
				coapRequestTemp.setPayload(payload);
				clientChannel.sendMessage(coapRequestTemp);
				System.out.println("Sent request\nSleeping for 5s before sending another");
				Thread.sleep(5000);
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
    }

	@Override
	public void onConnectionFailed(CoapClientChannel channel, boolean notReachable, boolean resetByServer) {
		System.out.println("Connection Failed");
	}

	@Override
	public void onResponse(CoapClientChannel channel, CoapResponse response) {
		System.out.println("Received response:" + response.toString());
		if (response.getToken()[0] == "g".getBytes()[0]) {
			System.out.println("Received key");
			// read private key from file
			try {
				String key = new String(Files.readAllBytes(new File("/home/pi/workspaceJava/COAP/ws4d-jcoap-applications/key.pem").toPath()), Charset.defaultCharset());
				String privateKeyPEM = key
					      .replace("-----BEGIN PRIVATE KEY-----", "")
					      .replaceAll(System.lineSeparator(), "")
					      .replace("-----END PRIVATE KEY-----", "");
				byte[] encoded = Base64.getDecoder().decode(privateKeyPEM);
				KeyFactory keyFactory = null;
				keyFactory = KeyFactory.getInstance("RSA");
				PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded);
			    this.privKey = (PrivateKey) keyFactory.generatePrivate(keySpec);
			    // decrypt payload and get session key
			    Cipher RSAcipher = Cipher.getInstance("RSA");
			    RSAcipher.init(Cipher.DECRYPT_MODE, this.privKey);
			    this.AESkey = RSAcipher.doFinal(response.getPayload());
			    System.out.println("Decrypted session key is: " + getHex(this.AESkey));
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		else {
			System.out.println("Received some message!");
			String respString = new String(response.getPayload(), StandardCharsets.UTF_8);
			if (respString.equals("Signature mismatch")) {
				// client compromised or intruder in network
				System.out.println("Signature mismatch...aborting");
				System.exit(1);
			}
			else if (respString.equals("Success")) {
				System.out.println("Server received and decrypted data successfully!");
			}
		}
	}
	
	public static String getHex(byte[] value) {
		String output = "";
		for(byte byteValue : value) {
			output += String.format("%02x", byteValue);
		}
		return output;
	}
}

```
## 3.5. Server code
```JAVA
package org.ws4d.coap.server;

import java.io.FileInputStream;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import org.ws4d.coap.connection.BasicCoapChannelManager;
import org.ws4d.coap.interfaces.CoapChannelManager;
import org.ws4d.coap.interfaces.CoapMessage;
import org.ws4d.coap.interfaces.CoapRequest;
import org.ws4d.coap.interfaces.CoapServer;
import org.ws4d.coap.interfaces.CoapServerChannel;
import org.ws4d.coap.messages.CoapMediaType;
import org.ws4d.coap.messages.CoapResponseCode;

public class BasicCoapServer implements CoapServer {
    private static final int PORT = 5683;
    static int counter = 0;
    byte[] AESkey = null; // suppose only 1 client - if more, create a hashmap with the objectid and instance
    public static void main(String[] args) {
        System.out.println("Start CoAP Server on port " + PORT);
        BasicCoapServer server = new BasicCoapServer();
        CoapChannelManager channelManager = BasicCoapChannelManager.getInstance();
        channelManager.createServerListener(server, PORT);
    }

	@Override
	public CoapServer onAccept(CoapRequest request){
		System.out.println("Accept connection...");
		return this;
	}

	@Override
	public void onRequest(CoapServerChannel channel, CoapRequest request) {
		System.out.println("Received message: " + request.toString()+ " URI: " + request.getUriPath());
		// load client cert for signature verification
		PublicKey pkClient = null;
		try {
			FileInputStream fCertInClient = new FileInputStream("CoAPClientX509.cer");
			CertificateFactory cf = CertificateFactory.getInstance("X.509");
			X509Certificate client = (X509Certificate) cf.generateCertificate(fCertInClient);
			pkClient = client.getPublicKey();
			fCertInClient.close();
		} catch (Exception e) {
			e.printStackTrace();
		}

		if (request.getUriPath().equals("/generate")) {
			byte[] cipheredAESkey = null;
			try {
				// generate random AES key for encryption
				SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG");
				this.AESkey = new byte[16];
				secureRandom.nextBytes(this.AESkey);
				System.out.println("Generated session key is: " + getHex(this.AESkey));
				// init RSA cipher and encrypt AES key with clients public key
				Cipher RSAcipher = Cipher.getInstance("RSA");
				RSAcipher.init(Cipher.ENCRYPT_MODE, pkClient);
				cipheredAESkey = RSAcipher.doFinal(this.AESkey);
			} catch (Exception e) {
				e.printStackTrace();
			}
			
			CoapMessage response = channel.createResponse(request,
					CoapResponseCode.Content_205);
			response.setContentType(CoapMediaType.octet_stream);
			response.setPayload(cipheredAESkey);
			channel.sendMessage(response);
		}
		else {
			CoapMessage response = channel.createResponse(request,
					CoapResponseCode.Content_205);
			response.setContentType(CoapMediaType.text_plain);
			byte[] recvPayload = request.getPayload();
			// obtain signature and encrypted payload
			byte[] aux = new byte[4];
			for(int i = 0; i < 4; i++) {
				aux[i] = recvPayload[i];
			}
			ByteBuffer bb = ByteBuffer.wrap(aux);
			int sizeOfSign = bb.getInt();
			byte[] sign = new byte[sizeOfSign];
			for(int i = 0; i < sizeOfSign; i++) {
				sign[i] = recvPayload[i + 4];
			}
			byte[] encPayload = new byte[recvPayload.length - sign.length - 4];
			for(int i = 0; i < encPayload.length; i++) {
				encPayload[i] = recvPayload[i + sign.length + 4];
			}
			try {
				// verify signature
				Signature signature = Signature.getInstance("SHA512withRSA");
				signature.initVerify(pkClient);
				signature.update(encPayload);
				boolean isCorrect = signature.verify(sign);
				if(isCorrect) {
					// decrypt payload
					System.out.println("Signature verified successfully");
					Cipher AEScipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
					SecretKeySpec keySpec = new SecretKeySpec(this.AESkey, "AES");
					AEScipher.init(Cipher.DECRYPT_MODE, keySpec);
					byte[] decryptedPayload = AEScipher.doFinal(encPayload);
					String recvJson = new String(decryptedPayload, StandardCharsets.UTF_8);
					System.out.println("Received data:\n" + recvJson);
					response.setPayload("Success");
				}	
				else {
					// panic
					System.out.println("Signature mismatch...client aborting");
					response.setPayload("Signature mismatch");
				}
			} catch (Exception e) {
				e.printStackTrace();
			}	
			channel.sendMessage(response);
		}	
	}

	@Override
	public void onSeparateResponseFailed(CoapServerChannel channel) {
		System.out.println("Separate response transmission failed.");
		
	}
	
	public static String getHex(byte[] value) {
		String output = "";
		for(byte byteValue : value) {
			output += String.format("%02x", byteValue);
		}
		return output;
	}
}

```
