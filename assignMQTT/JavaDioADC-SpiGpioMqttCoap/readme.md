# 1. Compilation steps
## 1.1 On Raspberry Pi
$ export JAVA_HOME=/usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/
$ export PATH=$PATH:$JAVA_HOME/bin
$ cd /home/pi/workspaceJava/MQTT/JavaDioADC-SpiGpioMqttCoap/src
$ export CLASSPATH_MQTT=.:../libs/org.eclipse.paho.client.mqttv3-1.0.2.jar
$ javac -classpath $CLASSPATH_MQTT -d ../build mqtt_paho_eclipse_mosquitto/client/MqttSubscribeClient.java mqtt_paho_eclipse_mosquitto/client/MqttPublishClient.java mqtt_paho_eclipse_mosquitto/client/MqttMiddleman.java
$ cd ../build
$ java -classpath $CLASSPATH_MQTT mqtt_paho_eclipse_mosquitto/client/MqttMiddleman
## 1.2. On Windows host
Open up the project in your editor of choice (Eclipse/IntelliJ etc...). Fix the classpath of the project(namely from where it loads the libraries), for Eclipse this is done by right-clicking on the project->Build Path->Configure build path, and then in the Libraries tab, click on each one, then Edit and then navigate to the respective location where the .jar is located.
Finally, run the project as a Java application.

# 2. Code
## 2.1. Chosen implementation
For this project, I've used the already provided implementation for the MQTT Publisher ("https://github.com/critoma/armasmiot/blob/master/labs/workspaceiotgwjava/JavaDioADC-SpiGpioMqttCoap/src/mqtt_paho_eclipse_mosquitto/client/MqttPublishClient.java") and removed all other files from the project ("https://github.com/critoma/armasmiot/tree/master/labs/workspaceiotgwjava/JavaDioADC-SpiGpioMqttCoap") keeping just the required libraries and the aforementioned file.
I've then proceeded to modify the publisher to include the required specifications for this assignment, namely authentication via digital signatures and confidentiality, via symmetric encryption and then created a subscriber client respecting the same requirements.
For authentication, I've generated 2 certificates, named "MqttPublisherX509.cer" and "MqttSubscriberX509.cer" (they were generated using keytool), which will be used for signature verification and for sending the session key. From said certificates, I've extracted the private key and saved them as "key_pub.pem", "key_sub.pem" respectively.(private keys were obtained by converting the jks key store generated by keytool, saving it as PKCS12 and then using openssl to extract the key). I have also removed the "Bag attributes" leftovers from key generation from the keys for easier parsing of the key.
The subscriber certificate is used in the publisher, specifically for using the public key associated with it to encrypt the session key. Then the subscriber uses his private key to decrypt it and obtain the session key.
The publisher certificate is used in the subscriber for signature verification upon receiving a message.
The communication is encrypted using a 128-bit AES key, randomly generated using the "SecureRandom" class.
## 2.2. MQTT Broker
The MQTT broker used is a local deployment of "Eclipse mosquitto". For it, download and install the mosquitto broker, then navigate to its install directory, open a "cmd.exe" and run "mosquitto.exe -p 1883" for Windows hosts, for Linux run "sudo apt-add-repository ppa:mosquitto-dev/mosquitto-ppa" and "sudo apt-get update" or "snap install mosquitto" if snap is available, and for MacOS run "brew install mosquitto"
## 2.3. Supposition
 - SUPPOSITION: On connecting to the MQTT broker, both the publisher and the subscriber send their certificate, and it becomes available for everyone to use. In this project, they are saved locally and used directly in code.
 ## 2.4. Generating the session AES key
The generation of the session key is done by the publisher. 
On the subscriber, it subscribes to the topic "1smBaC/test/gen" which will be used by the publisher to send the key. The publisher, upon connecting, first publishes a message to that topic, in order to establish the session key. The session key is generated using the "SecureRandom" class, and is encrypted with the subscribers public key (obtained from the certificate). The encrypted key is then published to the generation topic. Upon receiving the generation message, the subscriber decrypts the received message using his private key and obtains the session key. From there, every communication is encrypted using the session key.
## 2.5. MQTT Publisher
```JAVA
package mqtt_paho_eclipse_mosquitto.client;
import java.io.File;
import java.io.FileInputStream;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;

public class MqttPublishClient {
	String broker;
	String clientId;
	int qos;
	byte[] AESkey;
	PublicKey publKeySub;
	PrivateKey privKeyPub;
	MqttClient sampleClient;
	
	public MqttPublishClient(String brokerp, String clientIdp, int qosp) {
		this.broker = brokerp;
		this.clientId = clientIdp;
		this.qos = qosp;
		try {
			// load subscribers public key from certificate
			FileInputStream fCertInSub = new FileInputStream("MqttSubscriberX509.cer");
			CertificateFactory cf = CertificateFactory.getInstance("X.509");
			X509Certificate sub = (X509Certificate) cf.generateCertificate(fCertInSub);
			this.publKeySub = sub.getPublicKey();
			fCertInSub.close();
			// load publishers private key from PEM
			String key = new String(Files.readAllBytes(new File("C:\\Users\\alex\\Desktop\\fac\\materialeMaster\\an2\\sem1\\embedded robotics iot\\assignMQTT\\JavaDioADC-SpiGpioMqttCoap\\key_pub.pem").toPath()), Charset.defaultCharset());
			String privateKeyPEM = key
				      .replace("-----BEGIN PRIVATE KEY-----", "")
				      .replaceAll(System.lineSeparator(), "")
				      .replace("-----END PRIVATE KEY-----", "");
			byte[] encoded = Base64.getDecoder().decode(privateKeyPEM);
			KeyFactory keyFactory = null;
			keyFactory = KeyFactory.getInstance("RSA");
			PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded);
		    this.privKeyPub = (PrivateKey) keyFactory.generatePrivate(keySpec);
		    // init mqtt client and connect
            this.sampleClient = new MqttClient(broker, clientId, new MemoryPersistence());
            MqttConnectOptions connOpts = new MqttConnectOptions();
            connOpts.setCleanSession(true);
            System.out.println("PUBLISHER - MQTT Connecting to broker: "+broker);
            this.sampleClient.connect(connOpts);
            System.out.println("PUBLISHER - Connected");
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}

    public void publish(String topic) {
        try {

            if (topic.equals("1smBaC/test/gen")) {
            	// generate session key
            	SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG");
				this.AESkey = new byte[16];
				secureRandom.nextBytes(this.AESkey);
				System.out.println("PUBLISHER - Generated session key is: " + getHex(this.AESkey));
				// init RSA cipher and encrypt AES key with subscribers public key
				Cipher RSAcipher = Cipher.getInstance("RSA");
				RSAcipher.init(Cipher.ENCRYPT_MODE, publKeySub);
				byte[] cipheredAESkey = RSAcipher.doFinal(this.AESkey);
				// send encrypted session key
				MqttMessage message = new MqttMessage(cipheredAESkey);
	            message.setQos(qos);
	            sampleClient.publish(topic, message);
	            System.out.println("PUBLISHER - Message published");
            }
            else {
            	// suppose we have a temperature sensor which sends its values => objectId = 3303, resourceId = 5700, instanceId = 0
            	SecureRandom r = new SecureRandom();
				float random = -40f + r.nextFloat() * 80f;
				String jsonIPSO = "{\n\t\"timestamp\": " + System.currentTimeMillis() + ",\n\t\"values\": [{\n\t\t\"objectId\": 3303,\n\t\t\"instanceId\": 0,\n\t\t\"resourceId\": 5700,\n\t\t\"datatype\": Float,\n\t\t\"value\": " + random + "\n\t]}\n}";
				// init AES cipher to encrypt the JSON
				Cipher AEScipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
				SecretKeySpec keySpec = new SecretKeySpec(this.AESkey, "AES");
				AEScipher.init(Cipher.ENCRYPT_MODE, keySpec);
				byte[] encPayload = AEScipher.doFinal(jsonIPSO.getBytes());
				// prepare to sign and sign the encrypted payload
				Signature signature = Signature.getInstance("SHA512withRSA");
				signature.initSign(this.privKeyPub);
				signature.update(encPayload);
				byte[] sign = signature.sign();
				// add signature length at first position in payload; then add signature; then the actual encrypted payload
				int sizeOfPayload = 4 + sign.length + encPayload.length;
				byte[] payload = new byte[sizeOfPayload];
				ByteBuffer aux = ByteBuffer.allocate(4);
				aux.putInt(sign.length);
				for(int i = 0; i < 4; i++) {
					payload[i] = aux.array()[i];
				}
				for(int i = 4; i < sign.length + 4; i++) {
					payload[i] = sign[i - 4];
				}
				// payload[5] = (byte) 0xf5; - uncomment to test sign mismatch
				for(int i = sign.length + 4; i < sizeOfPayload; i++) {
					payload[i] = encPayload[i - sign.length - 4];
				}
				MqttMessage message = new MqttMessage(payload);
                message.setQos(qos);
                sampleClient.publish(topic, message);
                System.out.println("PUBLISHER - Data:\n" + jsonIPSO);
                System.out.println("PUBLISHER - Message published");
            }
            
        } catch(Exception me) {
            me.printStackTrace();
        }
    }
    
    public static String getHex(byte[] value) {
		String output = "";
		for(byte byteValue : value) {
			output += String.format("%02x", byteValue);
		}
		return output;
	}
    
	protected void finalize() throws MqttException {
		this.sampleClient.disconnect();
		System.out.println("PUBLISHER - MQTT Disconnected");
	}
}


```
## 2.6. MQTT Subscriber
```JAVA
package mqtt_paho_eclipse_mosquitto.client;

import java.io.File;
import java.io.FileInputStream;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.MqttCallback;
import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;

public class MqttSubscribeClient implements MqttCallback {
	String broker;
	String clientId;
	int qos;
	byte[] AESkey;
	PublicKey publKeyPub;
	PrivateKey privKeySub;
	MqttClient sampleClient;
	
	public MqttSubscribeClient(String brokerp, String clientIdp, int qosp) {
		this.broker = brokerp;
		this.clientId = clientIdp;
		this.qos = qosp;
		try {
			// load publishers public key from certificate
			FileInputStream fCertInPub = new FileInputStream("MqttPublisherX509.cer");
			CertificateFactory cf = CertificateFactory.getInstance("X.509");
			X509Certificate pub = (X509Certificate) cf.generateCertificate(fCertInPub);
			this.publKeyPub = pub.getPublicKey();
			fCertInPub.close();
			// load subscribers private key from PEM
			String key = new String(Files.readAllBytes(new File("C:\\Users\\alex\\Desktop\\fac\\materialeMaster\\an2\\sem1\\embedded robotics iot\\assignMQTT\\JavaDioADC-SpiGpioMqttCoap\\key_sub.pem").toPath()), Charset.defaultCharset());
			String privateKeyPEM = key
				      .replace("-----BEGIN PRIVATE KEY-----", "")
				      .replaceAll(System.lineSeparator(), "")
				      .replace("-----END PRIVATE KEY-----", "");
			byte[] encoded = Base64.getDecoder().decode(privateKeyPEM);
			KeyFactory keyFactory = null;
			keyFactory = KeyFactory.getInstance("RSA");
			PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded);
		    this.privKeySub = (PrivateKey) keyFactory.generatePrivate(keySpec);
		    // init mqtt connection and subscribe to given topic
 			this.sampleClient = new MqttClient(this.broker, this.clientId, new MemoryPersistence());
 			MqttConnectOptions connOpts = new MqttConnectOptions();
 			connOpts.setCleanSession(true);
 			sampleClient.setCallback(this);
            System.out.println("SUBSCRIBER - MQTT Connecting to broker: "+broker);
            this.sampleClient.connect(connOpts);
            System.out.println("SUBSCRIBER - Connected");

		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public void subscribe(String topic) {
		try {
			// subscribe to given topic
			sampleClient.subscribe(topic, this.qos);
		} catch (MqttException e) {
			e.printStackTrace();
		}
	}

	@Override
	public void connectionLost(Throwable arg0) {
		System.out.println("SUBSCRIBER - Connection lost due to:");
		arg0.printStackTrace();
		System.out.println(arg0.getMessage() + '\n' + arg0.getLocalizedMessage());
		System.out.println("SUBSCRIBER - Closing client");
		try {
			this.sampleClient.disconnect();
		} catch (MqttException e) {
			e.printStackTrace();
		}
		System.exit(1);
	}

	@Override
	public void deliveryComplete(IMqttDeliveryToken arg0) {
		try {
			System.out.println("SUBSCRIBER - Delivery complete:" + arg0.isComplete() + " for message " + arg0.getMessage());
		} catch (MqttException e) {
			e.printStackTrace();
		}
	}

	@Override
	public void messageArrived(String arg0, MqttMessage arg1) throws Exception {
		System.out.println("SUBSCRIBER - Message arrived on topic:" + arg0);
		if (arg0.equals("1smBaC/test/gen")) {
			Cipher RSAcipher = Cipher.getInstance("RSA");
		    RSAcipher.init(Cipher.DECRYPT_MODE, this.privKeySub);
		    this.AESkey = RSAcipher.doFinal(arg1.getPayload());
		    System.out.println("SUBSCRIBER - Decrypted session key is: " + getHex(this.AESkey));
		}
		else {
			byte[] recvPayload = arg1.getPayload();
			// obtain signature and encrypted payload
			byte[] aux = new byte[4];
			for(int i = 0; i < 4; i++) {
				aux[i] = recvPayload[i];
			}
			ByteBuffer bb = ByteBuffer.wrap(aux);
			int sizeOfSign = bb.getInt();
			byte[] sign = new byte[sizeOfSign];
			for(int i = 0; i < sizeOfSign; i++) {
				sign[i] = recvPayload[i + 4];
			}
			byte[] encPayload = new byte[recvPayload.length - sign.length - 4];
			for(int i = 0; i < encPayload.length; i++) {
				encPayload[i] = recvPayload[i + sign.length + 4];
			}
			try {
				// verify signature
				Signature signature = Signature.getInstance("SHA512withRSA");
				signature.initVerify(this.publKeyPub);
				signature.update(encPayload);
				boolean isCorrect = signature.verify(sign);
				if(isCorrect) {
					// decrypt payload
					System.out.println("SUBSCRIBER - Signature verified successfully");
					Cipher AEScipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
					SecretKeySpec keySpec = new SecretKeySpec(this.AESkey, "AES");
					AEScipher.init(Cipher.DECRYPT_MODE, keySpec);
					byte[] decryptedPayload = AEScipher.doFinal(encPayload);
					String recvJson = new String(decryptedPayload, StandardCharsets.UTF_8);
					System.out.println("SUBSCRIBER - Received data:\n" + recvJson);
				}	
				else {
					// panic
					System.out.println("SUBSCRIBER - Signature mismatch...publisher/connection compromised");
				}
			} catch (Exception e) {
				e.printStackTrace();
			}	
		}
	}
	
	public static String getHex(byte[] value) {
		String output = "";
		for(byte byteValue : value) {
			output += String.format("%02x", byteValue);
		}
		return output;
	}
	
	protected void finalize() throws MqttException {
		this.sampleClient.disconnect();
		System.out.println("SUBSCRIBER - MQTT Disconnected");
	}
}

```
## 2.7. MQTT Middleman
This is used to create the subscriber and subscribe to the required topics, namely the generation one and the one where the "sensor" will send its data ("1smBaC/test/3303/0/5700"). The "sensor" is supposed to be a temperature sensor, and according to IPSO it should have "objectID = 3300", and for sending the data it should have "resourceID = 5700". There being only one sensor, the "instanceID" attribute is set to 0.
Then it creates the publisher, publishes to the generation topic to trigger the generation of the session key, and then every 10s publishes its data.
It also provides both to the subscriber and publisher the broker's address, their clientID, the QoS chosen and the aforementioned topics.
```JAVA
package mqtt_paho_eclipse_mosquitto.client;

public class MqttMiddleman {

	public static void main(String[] args) throws InterruptedException {
		// create subscriber
		MqttSubscribeClient sub = new MqttSubscribeClient("tcp://127.0.0.1:1883", "subIsmBacTest", 2);
		sub.subscribe("1smBaC/test/gen");
		sub.subscribe("1smBaC/test/3303/0/5700");
		//create publisher
		MqttPublishClient pub = new MqttPublishClient("tcp://127.0.0.1:1883", "pubIsmBacTest", 2);
		pub.publish("1smBaC/test/gen");
		Thread.sleep(10000); // sleep 10s awaiting for key to be processed
		while(true) {
			pub.publish("1smBaC/test/3303/0/5700");
			Thread.sleep(10000); // sleep 10s before publishing again
		} 

	}

}
```
